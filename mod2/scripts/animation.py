#!/usr/bin/env python3
"""
Ising Model Animation Script
----------------------------
Creates interactive animations of 2D Ising model simulation results using Plotly.
Shows evolution of physical quantities with temperature and finite-size scaling.
"""

import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
import glob
from scipy.interpolate import interp1d
import os

class IsingAnimator:
    """Class to create animations of Ising model results."""
    
    # Known critical exponents for 2D Ising model
    CRITICAL_EXPONENTS = {
        'beta': 1/8,
        'nu': 1,
        'gamma': 7/4
    }
    
    # Theoretical critical temperature for 2D Ising model
    TC_THEORETICAL = 2.269
    
    def __init__(self):
        """Initialize the animator and load data."""
        self.data = self.load_data()
        self.Tc_estimate = None
        self.colors = px.colors.qualitative.Plotly
        
    def load_data(self):
        """Load all data files generated by the C simulation."""
        data_files = glob.glob("../data/ising_results_L*.dat")
        data = {}
        
        for file in data_files:
            try:
                # Extract lattice size from filename
                filename = os.path.basename(file)
                L = int(filename.split('_')[2].split('.')[0][1:])
                data[L] = np.loadtxt(file, skiprows=1)
                print(f"Loaded data for L={L}")
            except (IndexError, ValueError, OSError) as e:
                print(f"Error loading file {file}: {e}")
                continue
                
        if not data:
            print("No data files found. Please run the C simulation first.")
            
        return data
    
    def save_animation(self, fig, filename):
        """Save animation to the plots directory."""
        os.makedirs("../plots", exist_ok=True)
        fig.write_html(f"../plots/{filename}")
        print(f"Animation saved to ../plots/{filename}")
    
    def estimate_critical_temperature(self):
        """Estimate critical temperature from Binder cumulant crossing."""
        if not self.data:
            return self.TC_THEORETICAL
            
        L_values = sorted(self.data.keys())
        Tc_estimates = []
        
        # Use the two largest lattices for most accurate estimate
        if len(L_values) >= 2:
            L1, L2 = L_values[-2], L_values[-1]
            T1, U1 = self.data[L1][:, 0], self.data[L1][:, 4]
            T2, U2 = self.data[L2][:, 0], self.data[L2][:, 4]
            
            # Find crossing point by interpolation
            try:
                f1 = interp1d(T1, U1, kind='cubic', bounds_error=False, fill_value='extrapolate')
                f2 = interp1d(T2, U2, kind='cubic', bounds_error=False, fill_value='extrapolate')
                
                # Find where the difference is zero
                T_common = np.linspace(max(T1.min(), T2.min()), min(T1.max(), T2.max()), 1000)
                diff = f1(T_common) - f2(T_common)
                
                # Find zero crossing
                zero_crossings = np.where(np.diff(np.sign(diff)))[0]
                if len(zero_crossings) > 0:
                    idx = zero_crossings[0]
                    Tc_estimate = T_common[idx]
                    Tc_estimates.append(Tc_estimate)
                    print(f"Crossing point for L={L1} and L={L2}: T_c ≈ {Tc_estimate:.4f}")
            except Exception as e:
                print(f"Error estimating critical temperature: {e}")
        
        if Tc_estimates:
            self.Tc_estimate = np.mean(Tc_estimates)
            print(f"Estimated critical temperature: T_c ≈ {self.Tc_estimate:.4f}")
        else:
            self.Tc_estimate = self.TC_THEORETICAL
            print(f"Using theoretical critical temperature: T_c = {self.Tc_estimate:.4f}")
            
        return self.Tc_estimate
    
    def create_temperature_animation(self):
        """Create animation showing evolution with temperature."""
        if not self.data:
            return None
            
        # Get all temperature points
        all_temps = np.unique(np.concatenate([data[:, 0] for data in self.data.values()]))
        all_temps.sort()
        
        # Create figure with animation frames
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=('Magnetization', 'Susceptibility', 
                           'Specific Heat', 'Binder Cumulant'),
            specs=[[{"type": "scatter"}, {"type": "scatter"}],
                   [{"type": "scatter"}, {"type": "scatter"}]]
        )
        
        # Add traces for each lattice size (initially empty)
        L_values = sorted(self.data.keys())
        for i, L in enumerate(L_values):
            color = self.colors[i % len(self.colors)]
            
            # Magnetization
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='lines+markers', name=f'L={L}',
                          line=dict(color=color), marker=dict(size=6)),
                row=1, col=1
            )
            
            # Susceptibility
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='lines+markers', name=f'L={L}',
                          line=dict(color=color), marker=dict(size=6), showlegend=False),
                row=1, col=2
            )
            
            # Specific Heat
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='lines+markers', name=f'L={L}',
                          line=dict(color=color), marker=dict(size=6), showlegend=False),
                row=2, col=1
            )
            
            # Binder Cumulant
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='lines+markers', name=f'L={L}',
                          line=dict(color=color), marker=dict(size=6), showlegend=False),
                row=2, col=2
            )
        
        # Create frames for animation
        frames = []
        for temp in all_temps:
            frame_data = []
            
            for i, L in enumerate(L_values):
                # Get data for this lattice size
                data = self.data[L]
                
                # Find indices where temperature <= current temp
                idx = data[:, 0] <= temp
                temps_subset = data[idx, 0]
                M_subset = data[idx, 1]
                chi_subset = data[idx, 2]
                C_subset = data[idx, 3]
                U4_subset = data[idx, 4]
                
                # Add traces for this frame
                frame_data.append(
                    go.Scatter(x=temps_subset, y=M_subset, mode='lines+markers',
                              marker=dict(size=6), line=dict(width=2))
                )
                frame_data.append(
                    go.Scatter(x=temps_subset, y=chi_subset, mode='lines+markers',
                              marker=dict(size=6), line=dict(width=2))
                )
                frame_data.append(
                    go.Scatter(x=temps_subset, y=C_subset, mode='lines+markers',
                              marker=dict(size=6), line=dict(width=2))
                )
                frame_data.append(
                    go.Scatter(x=temps_subset, y=U4_subset, mode='lines+markers',
                              marker=dict(size=6), line=dict(width=2))
                )
            
            frames.append(go.Frame(data=frame_data, name=f"T={temp:.2f}"))
        
        # Add frames to figure
        fig.frames = frames
        
        # Add animation controls
        fig.update_layout(
            updatemenus=[{
                "type": "buttons",
                "buttons": [
                    {
                        "label": "Play",
                        "method": "animate",
                        "args": [None, {
                            "frame": {"duration": 100, "redraw": True},
                            "fromcurrent": True,
                            "transition": {"duration": 50}
                        }]
                    },
                    {
                        "label": "Pause",
                        "method": "animate",
                        "args": [[None], {
                            "frame": {"duration": 0, "redraw": False},
                            "mode": "immediate",
                        }]
                    }
                ],
                "direction": "left",
                "pad": {"r": 10, "t": 10},
                "showactive": False,
                "type": "buttons",
                "x": 0.1,
                "xanchor": "right",
                "y": 0,
                "yanchor": "top"
            }],
            sliders=[{
                "active": 0,
                "yanchor": "top",
                "xanchor": "left",
                "currentvalue": {
                    "prefix": "Temperature: ",
                    "suffix": "",
                    "visible": True,
                    "xanchor": "right"
                },
                "transition": {"duration": 300, "easing": "cubic-in-out"},
                "pad": {"b": 10, "t": 50},
                "len": 0.9,
                "x": 0.1,
                "y": 0,
                "steps": [{
                    "args": [[f"T={temp:.2f}"], {
                        "frame": {"duration": 300, "redraw": True},
                        "mode": "immediate",
                        "transition": {"duration": 300}
                    }],
                    "label": f"{temp:.2f}",
                    "method": "animate"
                } for temp in all_temps]
            }]
        )
        
        # Update layout
        fig.update_layout(
            height=800,
            width=1000,
            title_text="Ising Model Evolution with Temperature",
            showlegend=True
        )
        
        # Update axes labels
        fig.update_xaxes(title_text="Temperature", row=2, col=1)
        fig.update_xaxes(title_text="Temperature", row=2, col=2)
        fig.update_yaxes(title_text="Magnetization (M)", row=1, col=1)
        fig.update_yaxes(title_text="Susceptibility (χ)", row=1, col=2)
        fig.update_yaxes(title_text="Specific Heat (C)", row=2, col=1)
        fig.update_yaxes(title_text="Binder Cumulant (U4)", row=2, col=2)
        
        return fig
    
    def create_scaling_animation(self):
        """Create animation showing finite-size scaling collapse."""
        if not self.data:
            return None
            
        Tc = self.Tc_estimate or self.TC_THEORETICAL
        beta, nu, gamma = self.CRITICAL_EXPONENTS['beta'], self.CRITICAL_EXPONENTS['nu'], self.CRITICAL_EXPONENTS['gamma']
        
        # Get all temperature points
        all_temps = np.unique(np.concatenate([data[:, 0] for data in self.data.values()]))
        all_temps.sort()
        
        # Create figure with animation frames
        fig = make_subplots(
            rows=1, cols=2,
            subplot_titles=('Magnetization Scaling', 'Susceptibility Scaling')
        )
        
        # Add traces for each lattice size (initially empty)
        L_values = sorted(self.data.keys())
        for i, L in enumerate(L_values):
            color = self.colors[i % len(self.colors)]
            
            # Magnetization scaling
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='markers', name=f'L={L}',
                          marker=dict(color=color, size=8, opacity=0.7)),
                row=1, col=1
            )
            
            # Susceptibility scaling
            fig.add_trace(
                go.Scatter(x=[], y=[], mode='markers', name=f'L={L}',
                          marker=dict(color=color, size=8, opacity=0.7), showlegend=False),
                row=1, col=2
            )
        
        # Create frames for animation
        frames = []
        for temp in all_temps:
            frame_data = []
            
            for i, L in enumerate(L_values):
                # Get data for this lattice size
                data = self.data[L]
                
                # Find indices where temperature <= current temp
                idx = data[:, 0] <= temp
                temps_subset = data[idx, 0]
                M_subset = data[idx, 1]
                chi_subset = data[idx, 2]
                
                # Calculate scaling variables
                scaling_var = (temps_subset - Tc) * L**(1/nu)
                scaled_M = M_subset * L**(beta/nu)
                scaled_chi = chi_subset * L**(-gamma/nu)
                
                # Add traces for this frame
                frame_data.append(
                    go.Scatter(x=scaling_var, y=scaled_M, mode='markers',
                              marker=dict(size=8, opacity=0.7))
                )
                frame_data.append(
                    go.Scatter(x=scaling_var, y=scaled_chi, mode='markers',
                              marker=dict(size=8, opacity=0.7))
                )
            
            frames.append(go.Frame(data=frame_data, name=f"T={temp:.2f}"))
        
        # Add frames to figure
        fig.frames = frames
        
        # Add animation controls
        fig.update_layout(
            updatemenus=[{
                "type": "buttons",
                "buttons": [
                    {
                        "label": "Play",
                        "method": "animate",
                        "args": [None, {
                            "frame": {"duration": 100, "redraw": True},
                            "fromcurrent": True,
                            "transition": {"duration": 50}
                        }]
                    },
                    {
                        "label": "Pause",
                        "method": "animate",
                        "args": [[None], {
                            "frame": {"duration": 0, "redraw": False},
                            "mode": "immediate",
                        }]
                    }
                ],
                "direction": "left",
                "pad": {"r": 10, "t": 10},
                "showactive": False,
                "type": "buttons",
                "x": 0.1,
                "xanchor": "right",
                "y": 0,
                "yanchor": "top"
            }],
            sliders=[{
                "active": 0,
                "yanchor": "top",
                "xanchor": "left",
                "currentvalue": {
                    "prefix": "Temperature: ",
                    "suffix": "",
                    "visible": True,
                    "xanchor": "right"
                },
                "transition": {"duration": 300, "easing": "cubic-in-out"},
                "pad": {"b": 10, "t": 50},
                "len": 0.9,
                "x": 0.1,
                "y": 0,
                "steps": [{
                    "args": [[f"T={temp:.2f}"], {
                        "frame": {"duration": 300, "redraw": True},
                        "mode": "immediate",
                        "transition": {"duration": 300}
                    }],
                    "label": f"{temp:.2f}",
                    "method": "animate"
                } for temp in all_temps]
            }]
        )
        
        # Update layout
        fig.update_layout(
            height=500,
            width=1000,
            title_text="Finite-Size Scaling Evolution",
            showlegend=True
        )
        
        # Update axes labels
        fig.update_xaxes(title_text="(T - T_c) L<sup>1/ν</sup>", row=1, col=1)
        fig.update_xaxes(title_text="(T - T_c) L<sup>1/ν</sup>", row=1, col=2)
        fig.update_yaxes(title_text="M L<sup>β/ν</sup>", row=1, col=1)
        fig.update_yaxes(title_text="χ L<sup>-γ/ν</sup>", row=1, col=2)
        
        return fig

def main():
    """Main function to run the animation."""
    print("Ising Model Animation")
    print("=====================")
    
    # Initialize animator
    animator = IsingAnimator()
    
    if not animator.data:
        return
    
    # Estimate critical temperature
    animator.estimate_critical_temperature()
    
    # Create animations
    print("Creating temperature evolution animation...")
    temp_animation = animator.create_temperature_animation()
    
    print("Creating scaling animation...")
    scaling_animation = animator.create_scaling_animation()
    
    # Save animations
    if temp_animation:
        animator.save_animation(temp_animation, "temperature_evolution.html")
    
    if scaling_animation:
        animator.save_animation(scaling_animation, "scaling_evolution.html")
    
    print("Animations complete!")
    print("Animations saved to the plots/ directory.")

if __name__ == "__main__":
    main()