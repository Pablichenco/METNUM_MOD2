#!/usr/bin/env python3
"""
Ising Model Analysis Script
---------------------------
Analysis of 2D Ising model simulation results using Plotly.
"""

import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
import glob
from scipy.interpolate import interp1d
import os
import pathlib

def save_plot(fig, filename, parent_directory, format=None, width=None, height=None, scale=2):
    """
    Save a Plotly figure to a file in various formats.
    
    Parameters:
    fig: Plotly figure object
    filename: Output filename (including path)
    format: File format ('png', 'jpg', 'svg', 'pdf', 'html'). If None, inferred from filename.
    width: Width in pixels (optional)
    height: Height in pixels (optional)
    scale: Scale factor for resolution (default: 2)
    """
    import plotly.io as pio
    
    # Create plots directory if it doesn't exist
    #print("Entrando a analysis.py")
    # os.makedirs("../plots", exist_ok=True)
    os.makedirs(parent_directory + "/plots", exist_ok=True)
 
    # Determine format from filename if not specified
    if format is None:
        format = filename.split('.')[-1].lower()
    full_path = parent_directory + f"/plots/{filename}"
    
    try:
        if format == 'html':
            # Save as interactive HTML 
            fig.write_html(full_path, include_plotlyjs=True, auto_open=False)
            print(f"Interactive plot saved to {full_path}")
        else:
            # Save as static image 
            fig.write_image(full_path, format=format, width=width, height=height, scale=scale)
            print(f"Static plot saved to {full_path} ({format.upper()} format)")


        return True
    except Exception as e:
        print(f"Error saving plot to {full_path}: {e}")
        
        # If Kaleido is not installed, provide instructions
        if "kaleido" in str(e).lower():
            print("\nKaleido is required for static image export.")
            print("Install it with: pip install kaleido")
            print("Or for Anaconda: conda install -c conda-forge python-kaleido")
        
        return False

def load_data(parent_directory):
    """Load all data files generated by the C simulation"""
    # import pathlib
    import re

    # .absolute() obtiene la ruta absoluta del archivo actual.
    # Ruta del directorio padre
    # p = pathlib.Path(__file__).absolute().parent.parent
    
    data_files = glob.glob(parent_directory + "/data/ising_results_L*.dat")
    data = {}
    
    for file in data_files:
        try:
            # Extract lattice size from filename
            #L = int(file.split('_')[2].split('.')[0][1:])
            s =  file[-7:-4]
            L = int(re.sub('[^0-9]', '', s))

            data[L] = np.loadtxt(file, skiprows=1)
            print(f"Loaded data for L={L}")
        except (IndexError, ValueError) as e:
            print(f"Error parsing filename {file}: {e}")
            continue
                
    if not data:
        print("No data files found. Please run the C simulation first.")
            
    return data

def estimate_critical_temperature(data):
    """Estimate critical temperature from Binder cumulant crossing"""
    print("Entrando a estimate_critical_temperature")
    TC_THEORETICAL = 2.269
    
    if not data:
        print("    ** NO EXISTE DATA **")
        return TC_THEORETICAL
        
    L_values = sorted(data.keys())
    Tc_estimates = []
    
    # Use the two largest lattices for most accurate estimate
    if len(L_values) >= 2:
        L1, L2 = L_values[-2], L_values[-1]
        T1, U1 = data[L1][:, 0], data[L1][:, 4]
        T2, U2 = data[L2][:, 0], data[L2][:, 4]
        
        # Find crossing point by interpolation
        try:
            f1 = interp1d(T1, U1, kind='cubic', bounds_error=False, fill_value='extrapolate')
            f2 = interp1d(T2, U2, kind='cubic', bounds_error=False, fill_value='extrapolate')
            
            # Find where the difference is zero
            T_common = np.linspace(max(T1.min(), T2.min()), min(T1.max(), T2.max()), 1000)
            diff = f1(T_common) - f2(T_common)
            
            # Find zero crossing
            zero_crossings = np.where(np.diff(np.sign(diff)))[0]
            if len(zero_crossings) > 0:
                idx = zero_crossings[0]
                Tc_estimate = T_common[idx]
                Tc_estimates.append(Tc_estimate)
                print(f"Crossing point for L={L1} and L={L2}: T_c ≈ {Tc_estimate:.4f}")
        except Exception as e:
            print(f"Error estimating critical temperature: {e}")
    
    if Tc_estimates:
        Tc_estimate = np.mean(Tc_estimates)
        print(f"Estimated critical temperature: T_c ≈ {Tc_estimate:.4f}")
    else:
        Tc_estimate = TC_THEORETICAL
        print(f"Using theoretical critical temperature: T_c = {Tc_estimate:.4f}")
        
    return Tc_estimate

def plot_raw_data(data, parent_directory, Tc_estimate):
    """Plot the raw simulation data"""
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=('Magnetization vs Temperature', 
                       'Susceptibility vs Temperature',
                       'Specific Heat vs Temperature', 
                       'Binder Cumulant vs Temperature')
    )
    
    # Colors for different lattice sizes
    colors = px.colors.qualitative.Plotly
    
    for i, (L, values) in enumerate(data.items()):
        color = colors[i % len(colors)]
        T, M, chi, C, U4 = values.T
        
        # Magnetization
        fig.add_trace(
            go.Scatter(x=T, y=M, mode='lines+markers', name=f'L={L}',
                      line=dict(color=color), marker=dict(size=4)),
            row=1, col=1
        )
        
        # Susceptibility
        fig.add_trace(
            go.Scatter(x=T, y=chi, mode='lines+markers', name=f'L={L}',
                      line=dict(color=color), marker=dict(size=4), showlegend=False),
            row=1, col=2
        )
        
        # Specific Heat
        fig.add_trace(
            go.Scatter(x=T, y=C, mode='lines+markers', name=f'L={L}',
                      line=dict(color=color), marker=dict(size=4), showlegend=False),
            row=2, col=1
        )
        
        # Binder Cumulant
        fig.add_trace(
            go.Scatter(x=T, y=U4, mode='lines+markers', name=f'L={L}',
                      line=dict(color=color), marker=dict(size=4), showlegend=False),
            row=2, col=2
        )
    
    # Add vertical line at critical temperature
    for row in [1, 2]:
        for col in [1, 2]:
            fig.add_vline(x=Tc_estimate, line_dash="dash", line_color="red", 
                         annotation_text=f"T_c = {Tc_estimate:.3f}", row=row, col=col)
    
    # Update layout
    fig.update_layout(height=800, width=1000, title_text="Ising Model Simulation Results")
    fig.update_xaxes(title_text="Temperature", row=2, col=1)
    fig.update_xaxes(title_text="Temperature", row=2, col=2)
    fig.update_yaxes(title_text="Magnetization (M)", row=1, col=1)
    fig.update_yaxes(title_text="Susceptibility (χ)", row=1, col=2)
    fig.update_yaxes(title_text="Specific Heat (C)", row=2, col=1)
    fig.update_yaxes(title_text="Binder Cumulant (U4)", row=2, col=2)
    
    # Save the plot
    save_plot(fig, "ising_raw_data.png", parent_directory, width=1000, height=800, scale=2)
    save_plot(fig, "ising_raw_data.html",parent_directory)
    
    return fig

def finite_size_scaling(data, Tc_estimate):
    """Perform finite-size scaling analysis"""
    # Known critical exponents for 2D Ising model
    beta = 1/8
    nu = 1
    gamma = 7/4
    
    # Prepare data for scaling collapse
    scaling_data = {'magnetization': [], 'susceptibility': []}
    
    for L, values in data.items():
        T = values[:, 0]
        M = values[:, 1]
        chi = values[:, 2]
        
        # Scaling variable: t * L^(1/nu) where t = (T - Tc)/Tc
        scaling_var = (T - Tc_estimate) * L**(1/nu)
        
        # Scaled magnetization: M * L^(beta/nu)
        scaled_M = M * L**(beta/nu)
        scaling_data['magnetization'].append((scaling_var, scaled_M, L))
        
        # Scaled susceptibility: χ * L^(-gamma/nu)
        scaled_chi = chi * L**(-gamma/nu)
        scaling_data['susceptibility'].append((scaling_var, scaled_chi, L))
    
    return scaling_data

def plot_scaling_collapse(scaling_data, parent_directory):
    """Plot the scaling collapse"""
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=('Magnetization Scaling Collapse', 
                       'Susceptibility Scaling Collapse')
    )
    
    colors = px.colors.qualitative.Plotly
    
    for i, (scaling_var, scaled_M, L) in enumerate(scaling_data['magnetization']):
        color = colors[i % len(colors)]
        
        # Magnetization scaling
        fig.add_trace(
            go.Scatter(x=scaling_var, y=scaled_M, mode='markers', name=f'L={L}',
                      marker=dict(color=color, size=6, opacity=0.7)),
            row=1, col=1
        )
    
    for i, (scaling_var, scaled_chi, L) in enumerate(scaling_data['susceptibility']):
        color = colors[i % len(colors)]
        
        # Susceptibility scaling
        fig.add_trace(
            go.Scatter(x=scaling_var, y=scaled_chi, mode='markers', name=f'L={L}',
                      marker=dict(color=color, size=6, opacity=0.7), showlegend=False),
            row=1, col=2
        )
    
    # Update layout
    fig.update_layout(height=500, width=1000, title_text="Finite-Size Scaling Analysis")
    fig.update_xaxes(title_text="(T - T_c) L<sup>1/ν</sup>", row=1, col=1)
    fig.update_xaxes(title_text="(T - T_c) L<sup>1/ν</sup>", row=1, col=2)
    fig.update_yaxes(title_text="M L<sup>β/ν</sup>", row=1, col=1)
    fig.update_yaxes(title_text="χ L<sup>-γ/ν</sup>", row=1, col=2)
    
    # Save the plot
    save_plot(fig, "scaling_collapse.png", parent_directory, width=1000, height=500, scale=2)
    save_plot(fig, "scaling_collapse.html",parent_directory)
    
    return fig

def export_data_for_external_analysis(data):
    """Export processed data for external analysis tools."""
    if not data:
        return False
        
    try:
        import pandas as pd
        
        # Create a combined DataFrame
        combined_data = []
        for L, values in data.items():
            df = pd.DataFrame(values, columns=['T', 'M', 'chi', 'C', 'U4'])
            df['L'] = L
            combined_data.append(df)
        
        combined_df = pd.concat(combined_data, ignore_index=True)
    except Exception as e:
        print(f"Error in export_data_for_external_analysis(data): {e}" )
'''
def export_data_for_external_analysis(data, parent_directory):
        combined_df.to_csv(parent_directory + '/data/ising_combined_data.csv', index=False)
        print("Exported combined data to '../data/ising_combined_data.csv'")
        
        return True
    except ImportError:
        print("Pandas not available. Skipping data export.")
        return False
'''

def main():
    
    """Main function to run the analysis."""
    print("Ising Model Analysis")
    print("====================")
    
    # Load data
    print("Loading data...")
    parent_directory = str(pathlib.Path(__file__).absolute().parent.parent)
    data = load_data(parent_directory)
    
    if not data:
        print("No data files found. Please run the C simulation first.")
        return
    
    # Estimate critical temperature
    print("Estimating critical temperature...")
    Tc_estimate = estimate_critical_temperature(data)
    
    # Plot raw data
    print("Plotting raw data...")
    fig_raw = plot_raw_data(data, parent_directory, Tc_estimate)
    
    # Perform finite-size scaling
    print("Performing finite-size scaling...")
    scaling_data = finite_size_scaling(data, Tc_estimate)
    
    # Plot scaling collapse
    print("Plotting scaling collapse...")
    fig_scaling = plot_scaling_collapse(scaling_data, parent_directory)
    
    # Export data for external analysis
    print("Exporting data for external analysis...")
    export_data_for_external_analysis(data)
    
    # Show plots (if running in an environment that supports it)
    try:
        fig_raw.show()
        fig_scaling.show()
    except Exception as e:
        print(f"Could not display plots interactively: {e}")
        print("Check the plots/ directory for saved plot files.")
    
    print("Analysis complete! Check the plots/ directory for output files.")

if __name__ == "__main__":
    main()